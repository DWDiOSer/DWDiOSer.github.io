

---
layout: post
title: iOS 路由层研究与设计
date: 2017-03-30
---

iOS路由层研究与设计
一.背景简介
路由层的概念在服务端是指url请求的分层解析，将一个请求分发到对应的应用处理程序。移动端的路由层则是指将诸如App内页面访问、H5与App访问的访问请求和App间的访问请求，进行分发处理的逻辑层。
应用场景
1. H5页面与App原生页面、模块与组件的交互
2. App与App之间的相互访问
3. App内部页面跳转、模块调度与组件加载等
4. 推送与通知系统解除硬编码的逻辑，动态访问原生资源，更好的支持通过通知和推送完成动态页面访问和逻辑执行
5. 为App提供解除业务相互依赖的能力
6. 以组件化为目的的工程改造，隔离各个业务，以制作单独的组件
7. 一个简单的降级思路
8. 在组件间进行相关的埋点等
提出需求
1.点我达骑手端之前在最近的版本迭代中加入了登录页的插画需求，同时提出在未来的一些版本迭代中需要支持跳转逻辑，跳转到商城页或者其他APP又或者是App Store中，那么通过路由跳转的方式能不能实现？
2.在JSPatch不能用的情况下，在某些次级页面中发现bug,能否用路由的方式对页面进行降级，降级成H5或者跳转到某些不影响主逻辑的界面？
3.对一些耦合度极高的VC进行解耦？
4.跳转路径中的埋点过程？

二.路由的思路

首先，路由层在逻辑功能上的设计都是差不多的，路由层解决的核心问题就是原来界面或者组件之间相互调用都必须相互依赖，需要导入目标的头文件、需要清楚目标对象的逻辑，而现在全部都通过路由中转，只依赖路由或者某种通讯协议，或者依靠一些消息传递机制连路由都不依赖。其次，路由的核心逻辑就是目标匹配，对于外部调用的情况来说，URL如何匹配Handler是最为重要的，匹配就必然用到正则表达式。


然后，对于本次课题的一些需求思路。从以下角度去考虑：
1.路由需要能够实现被其他模块调度，从而调度另外一个模块
2.接入路由的模块不需要知道目标模块的实现
3.调度发起方需要有目标的响应回调，类似于http请求，有一个request就要有一个response，才能实现双向的调用
4.调用方式需要统一，统一而松散的调用协议和数据协议可以减少大量接入成本和沟通成本

三.路由的设计思路的大致框架

![](路由.jpeg)
首先，Router就是一个实例对象，用来提供给其他的模块调用。之后就是路由层的请求，无论是跨应用的外部调用(H5调用、其他App调用)还是内部调用(内部模块相互调用)，最后都要形成一个路由请求，一个以URL为基础的request对象，首先需要有携带URL，再一个要携带请求所需要的参数，参数有三种，一种是Url上的键值对参数，一种是RESTFul风格的Url上的路径参数，一种是内部调用适用的原生参数。那么，routerRequest是个以URL为基础的实例对象，这里不是直接传URL字符串的主要考虑是，如果路由在内部调用其他模块的时候需要传入一些原生对象，而URL上只能携带类型单一的字符串键值对表示参数，所以需要使用这么一个对象进行包装。
然后，handler层处理一个request请求是一个具有过程性的逻辑，RouteHandler要作为一个基类，这个handler在需要处理获取目标视图控制器->参数传递给目标视图控制器->视图控制器的转场->完成回调这样一个实现思路，所以当路由接收一个routeRequest请求，转发给一个routeHandler处理，处理完毕以后如果有回调，则回调给调用者。URL的请求与Handler的对应关系肯定需要匹配的逻辑。
最后，为了使得路由内部逻辑更加清晰单独使用routeMatcher来处理匹配的逻辑，可以通过传入url和参数，检查是否返回request请求，来表示该routeMatcher对象所拥有的匹配表达式与url是否能够匹配
![](路由2.jpeg)
工作流程：
1. 首先实例化Router对象
2. 实例化Handler或者是Block，通过Router的注册接口使得一个Url的匹配表达式对应一个Handler或者是一个block
3. Router内部会将Url的表达式形成一个Matcher对象进行保存，对应的Handler或处理的Block会与Matcher一一对应，怎么对应呢？应该使用路由表达式进行关联
4. Router通过handle方法，接收一个Url的请求，内部遍历所有的Matcher对象，将Url和参数转换为Request对象，如果能转换为Request对象则说明能匹配，如果不能则说明该Url不能被路由实体处理
5. 拿到Request对象以后，则根据Matcher对应的路由表达式找到对应的Handler或者是Block
6. 根据Handler的几个关键方法，传入Request对象，按照顺序完成处理逻辑的触发，最后如果有request当中包含有目标的回调，则将处理结果通过回调的Block响应给调用方法
7. Handler完成处理后，Router完成本次路由请求

四.git上主流的几个路由的源码分析
关于组件化或者模块化的实现，网上早就有很多的讨论，例如蘑菇街的组件化思路【https://github.com/meili/MGJRouter】 基本就是依靠路由来实现的，以及蘑菇街对应技术的博客【http://limboy.me/tech/2016/03/10/mgj-components.html 】所以简单的来说说git上比较主流的几个路由的源码。
1.JLRoutes 【https://github.com/joeldev/JLRoutes 】
//code
2.HHRoutes 【https://github.com/lightory/HHRouter 】
//code
3.MGJRouter 【https://github.com/meili/MGJRouter 】
//code 

五.解决问题

六.缺点以及讨论





